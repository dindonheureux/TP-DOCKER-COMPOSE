

#############################################################################################################################################################################
                                                                 CE README A ETE COPIE SUR LE GITHUB DE DAMIEN
#############################################################################################################################################################################


# üìö Explication D√©taill√©e du TP Stack LAMP avec Docker Compose

## üéØ Objectif du TP

Ce TP vise √† cr√©er une **stack LAMP** compl√®te en utilisant **Docker Compose**. Une stack LAMP est un ensemble de technologies permettant de cr√©er des applications web dynamiques.

---

## üî§ Qu'est-ce qu'une Stack LAMP ?

**LAMP** est l'acronyme de :
- **L**inux : Syst√®me d'exploitation
- **A**pache : Serveur web
- **M**ySQL : Base de donn√©es
- **P**HP : Langage de programmation c√¥t√© serveur

Ces 4 composants travaillent ensemble pour h√©berger et ex√©cuter des sites web dynamiques.

---

## üê≥ Pourquoi Docker et Docker Compose ?

### Docker
**Docker** permet de cr√©er des **conteneurs** : des environnements isol√©s qui contiennent tout ce dont une application a besoin pour fonctionner (code, d√©pendances, configuration).

**Avantages :**
- ‚úÖ Isolation : chaque service tourne dans son propre conteneur
- ‚úÖ Portabilit√© : fonctionne partout de la m√™me mani√®re
- ‚úÖ Rapidit√© : d√©marrage instantan√© vs machines virtuelles
- ‚úÖ Reproductibilit√© : m√™me environnement sur tous les ordinateurs

### Docker Compose
**Docker Compose** permet de d√©finir et g√©rer plusieurs conteneurs en m√™me temps via un seul fichier de configuration (`docker-compose.yml`).

**Avantages :**
- ‚úÖ Configuration centralis√©e
- ‚úÖ Gestion simplifi√©e de plusieurs services
- ‚úÖ D√©finition des d√©pendances entre services
- ‚úÖ Lancement/arr√™t de toute la stack en une commande

---

## üìÇ Structure du Projet

```
TP-Docker-Compose/
‚îú‚îÄ‚îÄ docker-compose.yml          # Orchestration de tous les services
‚îú‚îÄ‚îÄ php/
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile              # Instructions pour construire l'image PHP
‚îú‚îÄ‚îÄ apache/
‚îÇ   ‚îî‚îÄ‚îÄ my-vhost.conf           # Configuration du serveur Apache
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ index.php               # Code PHP de test
```

### Pourquoi cette structure ?

- **docker-compose.yml** : Point central qui d√©finit tous les services
- **php/** : Contient le Dockerfile car PHP n√©cessite une image personnalis√©e (avec extensions MySQL)
- **apache/** : Configuration personnalis√©e pour qu'Apache communique avec PHP-FPM
- **src/** : Code source de votre application web

---

## üìÑ Explication des Fichiers Cr√©√©s

### 1. docker-compose.yml

```yaml
version: '3.8'  # Version de la syntaxe Docker Compose

services:       # Liste des services (conteneurs)
```

#### Service Apache
```yaml
apache:
  image: httpd:2.4                    # Image officielle Apache version 2.4
  container_name: apache_container    # Nom personnalis√© du conteneur
  ports:
    - "8080:80"                       # Port h√¥te:Port conteneur
                                      # Acc√®s externe via 8080 ‚Üí redirig√© vers port 80 du conteneur
  volumes:
    - ./src:/var/www/html             # Montage du code source
    - ./apache/my-vhost.conf:/usr/local/apache2/conf/httpd.conf  # Config personnalis√©e
  depends_on:
    - php                             # Attend que PHP d√©marre
    - db                              # Attend que MySQL d√©marre
  networks:
    - lamp_network                    # R√©seau partag√© entre tous les services
```

**Explications :**
- **image** : On utilise l'image officielle Apache (httpd) depuis Docker Hub
- **ports** : `8080:80` signifie que le port 8080 de votre VM redirige vers le port 80 du conteneur Apache
- **volumes** : Permet de partager des fichiers entre l'h√¥te et le conteneur (pratique pour modifier le code sans reconstruire l'image)
- **depends_on** : Indique l'ordre de d√©marrage des conteneurs
- **networks** : Tous les services sur le m√™me r√©seau peuvent communiquer entre eux par leur nom

#### Service MySQL (db)
```yaml
db:
  image: mysql:8.0                    # Image officielle MySQL 8.0
  container_name: mysql_container
  environment:                        # Variables d'environnement pour configurer MySQL
    MYSQL_ROOT_PASSWORD: rootpassword # Mot de passe du compte root
    MYSQL_DATABASE: company           # Cr√©ation automatique de la BDD "company"
    MYSQL_USER: user                  # Cr√©ation d'un utilisateur "user"
    MYSQL_PASSWORD: password          # Mot de passe de cet utilisateur
  volumes:
    - mysql_data:/var/lib/mysql       # Persistance des donn√©es (volume nomm√©)
  networks:
    - lamp_network
```

**Explications :**
- **environment** : Configuration de MySQL via variables d'environnement (pas besoin de se connecter pour la configuration initiale)
- **MYSQL_DATABASE** : Cr√©e automatiquement une base de donn√©es au d√©marrage
- **volumes** : `mysql_data` est un **volume nomm√©** (g√©r√© par Docker) qui persiste les donn√©es m√™me si le conteneur est supprim√©

#### Service PHP
```yaml
php:
  build:
    context: ./php                    # Dossier contenant le Dockerfile
    dockerfile: Dockerfile            # Nom du Dockerfile
  container_name: php_container
  volumes:
    - ./src:/var/www/html             # M√™me code source que Apache
  depends_on:
    - db                              # Attend MySQL
  networks:
    - lamp_network
```

**Explications :**
- **build** : Contrairement aux autres services, on **construit** l'image PHP depuis un Dockerfile
- **Pourquoi un Dockerfile ?** Car l'image PHP de base ne contient pas les extensions MySQL (mysqli, pdo_mysql) n√©cessaires

#### R√©seaux et Volumes
```yaml
networks:
  lamp_network:                       # R√©seau priv√© pour tous les conteneurs
    driver: bridge                    # Type de r√©seau (bridge = r√©seau interne)

volumes:
  mysql_data:                         # Volume pour persister les donn√©es MySQL
```

---

### 2. php/Dockerfile

```dockerfile
FROM php:8.1-fpm                      # Image de base : PHP 8.1 avec PHP-FPM

# Installation des extensions PHP pour MySQL
RUN docker-php-ext-install mysqli pdo pdo_mysql

# Installation d'outils suppl√©mentaires
RUN apt-get update && apt-get install -y \
    git \
    curl \
    zip \
    unzip

WORKDIR /var/www/html                 # R√©pertoire de travail par d√©faut

EXPOSE 9000                           # PHP-FPM √©coute sur le port 9000

CMD ["php-fpm"]                       # Commande lanc√©e au d√©marrage du conteneur
```

**Explications :**

#### PHP-FPM (FastCGI Process Manager)
- PHP-FPM est un gestionnaire de processus PHP optimis√© pour les serveurs web
- Il √©coute sur le port 9000 et attend des requ√™tes d'Apache
- Apache fait office de **proxy** : il re√ßoit les requ√™tes HTTP et les transf√®re √† PHP-FPM

#### Extensions PHP
- **mysqli** : Extension MySQL am√©lior√©e (orient√©e objet)
- **pdo** : PHP Data Objects (couche d'abstraction pour bases de donn√©es)
- **pdo_mysql** : Driver MySQL pour PDO

Sans ces extensions, PHP ne pourrait pas se connecter √† MySQL !

---

### 3. apache/my-vhost.conf

Ce fichier configure Apache pour :

#### Charger les modules n√©cessaires
```apache
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so
```
Ces modules permettent √† Apache de communiquer avec PHP-FPM via le protocole FastCGI.

#### D√©finir le DocumentRoot
```apache
DocumentRoot "/var/www/html"
<Directory "/var/www/html">
    Options Indexes FollowSymLinks
    AllowOverride All
    Require all granted
    DirectoryIndex index.php index.html
</Directory>
```
- **DocumentRoot** : Racine du site web
- **DirectoryIndex** : Fichier par d√©faut (index.php puis index.html)
- **AllowOverride All** : Permet l'utilisation de fichiers .htaccess

#### Configuration du proxy PHP
```apache
<FilesMatch \.php$>
    SetHandler "proxy:fcgi://php_container:9000"
</FilesMatch>
```
**C'est la cl√© du syst√®me !**
- Quand Apache re√ßoit une requ√™te pour un fichier `.php`, il ne l'ex√©cute pas lui-m√™me
- Il transmet la requ√™te au conteneur PHP-FPM (`php_container:9000`)
- PHP-FPM ex√©cute le code PHP et renvoie le r√©sultat √† Apache
- Apache renvoie la r√©ponse au client

**Note importante** : `php_container` fonctionne car Docker Compose cr√©e automatiquement un DNS interne qui r√©sout les noms de services.

---

### 4. src/index.php

```php
<?php
echo "<h1>Test de la Stack Docker Compose</h1>";

// Test PHP
echo "<p>‚úÖ PHP fonctionne (Version " . phpversion() . ")</p>";

// Test Connexion MySQL
$servername = "db";              // Nom du service dans docker-compose.yml
$username = "user";              // Utilisateur cr√©√© via MYSQL_USER
$password = "password";          // Mot de passe d√©fini via MYSQL_PASSWORD
$dbname = "company";             // Base de donn√©es cr√©√©e via MYSQL_DATABASE

// Cr√©ation de la connexion
$conn = new mysqli($servername, $username, $password, $dbname);

// V√©rification
if ($conn->connect_error) {
    die("<p style='color:red'>‚ùå Echec de la connexion MySQL : " . $conn->connect_error . "</p>");
}

echo "<p style='color:green'>‚úÖ Succ√®s ! PHP est connect√© √† MySQL.</p>";
?>
```

**Points importants :**
- `$servername = "db"` : On utilise le **nom du service** d√©fini dans docker-compose.yml, pas une IP !
- Docker Compose r√©sout automatiquement `db` vers l'IP du conteneur MySQL
- Les identifiants correspondent aux variables d'environnement du service MySQL

---
